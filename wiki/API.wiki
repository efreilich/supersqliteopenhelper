*NOT COMPLETE* This is a work in progress as I work to convert all my comment blocks into a more web-friendly format.
<br><br><br>

=Public Methods=
{{{
public SuperSQLiteOpenHelper(Context context, String DB_Name, int DB_Version, String[][][] DB_Schema)
}}}
Constructor.  Creates a new version of the database helper.  Since this class is abstract, this is where the database information such as name, version, and schema are initialized.<br>
*Inputs:*
|| context (Context) || the active context of the app ||
|| DB_Name (String)) || name of the database ||
|| DB_Version (int)) || version of the database ||
|| DB_Schema (String[][][])) || schema of the database (syntax above) ||

*Output:* The new object<br>

*Throws:* None

<br>
{{{
public void onCreate(SQLiteDatabase db)
}}}
This function handles the creation of a new database. This is done by simply creating all tables listed in the schema. The createTable function handles versioning.<br>
This function is automatically by Android when useWritableDatabase or useReadableDatabase is called (not called directly).<br>
*Inputs:*
|| db (SQLiteDatabase) || the database ||

*Output:* None<br>
*Throws:* SQLException if error in database schema

<br>
{{{
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)
}}}
This function handles the upgrade to a newer version of the database.  If a table already existed in a previous version, new columns are added to it.  If not, the table is created from scratch.<br>
This function is automatically by Android when useWritableDatabase or useReadableDatabase is called (not called directly).<br>
*Inputs:*
|| db (SQLiteDatabase) || the database ||
|| oldVersion (int) || the current version (lower) ||
|| newVersion (int) || the target version (higher) ||

*Output:* None<br>
*Throws:* SQLException if error in database schema

<br>
{{{
public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion)
}}}
This function handles the downgrade to an older version of the database.  Since dropping columns is not allowed in SQLite, each existing table is renamed to a temporary name.  Then, the old version of the tables are created and all old data is moved to the old versions.  Lastly, the temp tables are deleted.<br>
This function is automatically by Android when useWritableDatabase or useReadableDatabase is called (not called directly).<br>
*Inputs:*
|| db (SQLiteDatabase) || the database ||
|| oldVersion (int) || the current version (higher) ||
|| newVersion (int) || the target version (lower) ||

*Output:* None<br>
*Throws:* SQLException if error in database schema

<br>
{{{
private boolean createTable( SQLiteDatabase db, int index) throws SQLException
}}}
This function is a helper function used by the onCreate, onUpgrade/Downgrade functions to create individual tables. This function takes an index into the schema array to the specific table to be created.  This creates all columns and adds any listed constraints.  If created successfully, the function returns true. If the table does not exist in the current version, it is skipped and the function returns false.<br>
This function is automatically by other automatic functions (not called directly).<br>
*Inputs:*
|| db (SQLiteDatabase) || the database ||
|| index (int) || position in schema array of table to create ||

*Output:* Boolean<br>
 * True if table was created
 * False if table was not created (table does not exist in current version)<br>
*Throws:* SQLException if error in database schema

<br>
{{{
public SQLiteDatabase getActiveDB()
}}}
Returns the database object in case the developer wants to interact in a non-supported way.<br>
*Inputs:* None<br>
*Output:* SQLiteDatabase - the reference to the internal active database object<br>
*Throws:* None

<br>
{{{
public void useWritableDatabase()
}}}
Opens a writeable copy of the database and saves it to an internal variable for later use. If there is an existing version open, it is first closed.<br>
*Inputs:* None<br>
*Output:* None<br>
*Throws:* None

<br>
{{{
public void useReadableDatabase()
}}}
Opens a readable copy of the database and saves it to an internal variable for later use. If there is an existing version open, it is first closed.<br>
*Inputs:* None<br>
*Output:* None<br>
*Throws:* None

<br>
{{{
public void close()
}}}
Closes the internal reference to the database.<br>
*Inputs:* None<br>
*Output:* None<br>
*Throws:* None

<br>
{{{
public boolean cleanDatabase(SQLiteDatabase activeDB_)
}}}
This function cleans the database by deleted all records in all tables.  This is not done in a transaction and is not rolled back if there is an error. If you need a transaction, place the database to be passed in in a transaction and act accordingly.<br>
*Inputs:*
|| activeDB_ (SQLiteDatabase || the database to clean ||
*Output:* Boolean
 * True if cleaned completely
 * False if an error occurred
*Throws:* SQLException if error in database schema

<br>
{{{
public boolean cleanDatabase()
}}}
This is a convenience method to call the above version of cleanDatabase.  This functions get a writable copy of the database and passes it to the above function.<br>
*Inputs:* None
*Output:* Boolean
 * True if cleaned completely
 * False if an error occurred
*Throws:* SQLException if error in database schema

<br>
{{{
public boolean exportToFile( File dest )
}}}
This function will export this database to a given file in an xml format.<br>
*Inputs:*
|| dest (File) || the file to export to ||
*Output:* Boolean
 * True if successful
 * False if not
*Throws:* None

<br>
{{{
public Element exportToElement()
}}}
This function will export this database document element.<br>
*Inputs:* None
*Output:* Element
 * The document element containing the database
 * Null if error
*Throws:* None

<br>
{{{
private static String docNodeToXMLString(Node root)
}}}
This is a recursive function that will convert an entire document to an xml string.  If necessary, the function will call itself for any children nodes.  If called on the root node, an xml header will be inserted.  Attributes are supported but are not used in the exportToFile function.<br>
*Inputs:*
Inputs:
|| root (Node) || the node at which to start building xml ||
*Output:* String || The xml string representing the document
*Throws:* None

<br>
{{{
public int importFromFile( File source, boolean append )
}}}
This function will import data from a given xml file into this database.  If append is false, the database will be cleaned before import.  The import will only import the tables/columns that exist in the database and will ignore extra data.  Missing columns (in case of import from older version) will be inserted as null.  If these columns are non-null, the import will fail and an error will be returned. If a constraint is violated, the import will fail and an error will be returned (this can be avoided if 'ON CONFLICT' is specified as IGNORE or REPLACE - see SQLite documentation). It is up to the developer to handle these reported errors as appropriate.<br>
For now, non-null and constraint violations are indistinguishable. However, this may be fixed in the future (insertWithOnConflict is available in Android API Level 8).<br>
*Inputs:*
|| source (File) || the file to import from ||
|| append (boolean) || append to database (false to clean it first) ||
*Output:* int || import return code
*Throws:* None

<br>
{{{
public int importFromElement( Element dbTables, boolean append )
}}}
This function will import data from a given document element.  If append is false, the database will be cleaned before import.  The import will only import the tables/columns that exist in the database and will ignore extra data.  Missing columns (in case of import from older version) will be inserted as null.  If these columns are non-null, the import will fail and an error will be returned. If a constraint is violated, the import will fail and an error will be returned (this can be avoided if 'ON CONFLICT' is specified as IGNORE or REPLACE - see SQLite documentation). It is up to the developer to handle these reported errors as appropriate.<br>
For now, non-null and constraint violations are indistinguishable. However, this may be fixed in the future (insertWithOnConflict is available in Android API Level 8).<br>
*Inputs:*
|| dbTables (Element) || document with data in it ||
|| append (boolean) || append to database (false to clean it first) ||
*Output:* int || import return code
*Throws:* None

<br>
{{{
private void fillTableFromXML(SQLiteDatabase db, String thisTable, String[] theseColumns, NodeList myRecords)
}}}
This function will insert data into a database. The database to be inserted into, the table and columns in insert into, and the data to insert.<br>
*Inputs:*
|| db (SQLiteDatabase) || the database to insert into ||
|| thisTable (String) || the table to insert into ||
|| theseColumns (String[]) || the columns to insert into the table ||
|| myRecords (NodeList) || the data to fill the table ||
*Output:* None
*Throws:* None

<br>
To Be Continued...